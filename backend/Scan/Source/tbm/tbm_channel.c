/* Copyright (c) 2001 by Medtronic Inc.  All Rights Reserved */
/********************************************************************
DOCUMENT

$Revision$

$Date$

$RCSfile$

MODULE:
  tbm_channel.c  area = Telemetry B State Machine Interface

FUNCTIONS:
   tbm_activate
   tbm_autoIDDone
   tbm_autoIDFail
   tbm_captureDataDone
   tbm_checkAutoIDDone
   tbm_closeDone
   tbm_closeSession
   tbm_concludeAutoID
   tbm_continueAutoID
   tbm_createDLframes
   tbm_deviceIDTx
   tbm_doAutoID
   tbm_doReturn
   tbm_EGMtimerExp
   tbm_FreeFrame
   tbm_initLinkMode1
   tbm_listenForDeviceIDResp
   tbm_listenForOpenDResp
   tbm_lossOfTelemetry
   tbm_noResp
   tbm_noTx
   tbm_openFail
   tbm_openSession
   tbm_processDeviceIDResp
   tbm_processMissedWf
   tbm_processOpenResp
   tbm_processULnonWFFrame
   tbm_processULWaveform
   tbm_processWFOpenResp
   tbm_startDataRxTimer
   tbm_stopLinkMode1
   tbm_stopSession
   tbm_tlmAbuse
   tbm_txTimeoutMode1
   tbm_txTimeoutMode2
   tbm_unexpTelemEvent

DESCRIPTION:
  This file contains the functions which are called as a result of a
  fsm (functional state machine) operation.  The prototypes for these
  have been automatically generated by the State Map Compiler (SMC)
  and are contained in the tbm_fsm.h file.

ENDDOCUMENT
********************************************************************/
#include "link.h"
#include "..\types.h"
#include <string.h>
#include "tbm_fsm.h"
#include "tbm_events.h"
#include "tbt_handler.h"
#include "tbm_handler.h"
#include "tbm_queue.h"
#include "tbm_autoid.h"

#define DEFINED_HERE
#include "tbm_channel.h"
#undef DEFINED_HERE

#include "tbm_timer.h"
#include "..\bsm\bsm_Event.h"
#include "tbm_main.h"
#include "tbm_rcv.h"
#include "tbm_tctl.h"
#include "tbm_trx.h"


/* Declare an instance of the Channel State Machine */
tbm_AutoID tbv_AutoID;

/* Declare the queue to store downlink frames to be sent to the Link
   for transmission. This queue is used only for App Data frames which
   are to be sent synchronously while in session with a device.*/
tbt_dlFrameType tbv_dlFrames[TBC_DL_FRAME_Q_SIZE];

/*************************************
        TIMERS
*************************************/

extern void tbm_hsTimerExp(void);


/*************************************
        Local functions
*************************************/
void tbm_createDLframes(void);

UINT16 openSessionCnt=0;

/********************************************************************

FUNCTION: tbm_activate

DESCRIPTION:
  This function initializes Telemetry Channel and Telemetry Link operations.
  It is called as a result of the Application calling the tbm_telemBInitialize
  Telemetry Handler function.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.  Could be used
  to pass parameters to state machine objects.

OUTPUTS:
  none

********************************************************************/
void tbm_activate(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_activate = TRUE;

    /*
       Initialize the Event Manager.
     */
    tbm_initializeEvents();

    /*
       Initialize the downlink Frame queue.
     */
    tbm_initializeQueue((TBC_DL_FRAME_Q_SIZE), &tbv_dlFrameQ);

    /*
       Initialize the uplink Frame queue.
     */
    tbm_initializeQueue((TBC_UL_FRAME_Q_SIZE), &tbv_ulFrameQ);

    /*
       Initialize the Timer list.
     */
    tbm_initTimers();

    return;
}

/********************************************************************

FUNCTION:  tbm_autoIDDone

DESCRIPTION:
  This function performs operations to conclude the tbm_telemBAutoID
  operation when the operation has completed without any failures.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.  Could be used
  to pass parameters to state machine objects.

OUTPUTS:
  none

********************************************************************/
void tbm_autoIDDone(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_autoIDDone = TRUE;
    tbm_clearMoreEventsFlag();
    tbm_cancelTimer(tbc_RxTimer);
    tbm_cancelTimer(tbc_TxTimer);
    tbm_disablePhysLayer(TRUE);
    return;
}

/********************************************************************

FUNCTION:  tbm_autoIDFail

DESCRIPTION:
   This function performs operations to conclude the tbm_telemBAutoID
   operation when the Auto ID operation has failed for any reason.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.  Could be used
  to pass parameters to state machine objects.

OUTPUTS:
  none

********************************************************************/
void tbm_autoIDFail(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_autoIDFail = TRUE;
    tbm_clearMoreEventsFlag();
    tbv_session.sessionStatus               = tbc_not_successful;
    tbm_cancelTimer(tbc_RxTimer);
    tbm_cancelTimer(tbc_TxTimer);
    return;
}

/********************************************************************

FUNCTION:
  tbm_captureDataDone

DESCRIPTION:
  This function concludes either the tbm_telemBData or tbm_telemBUplinks
  operation when all of the requested Data has been captured and the operation
  has completed with no failures.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_captureDataDone(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_captureDataDone = TRUE;

    /*
       Terminate event processor.
     */
    tbm_clearMoreEventsFlag();

    /*
       Clean up timers.
     */
    if (NULL != tbv_session.AppDataReqPtr) {
        /*
           Clear out the App Data timer.
         */
        tbm_cancelTimer(tbc_RxTimer);
        tbm_cancelTimer(tbc_TxTimer);
    }
    else  {                       /* Clear out the EGM capture timer. */
        tbm_cancelTimer(tbc_EGMTimer);
    }

    return;
}

/********************************************************************

FUNCTION:
  tbm_checkAutoIDDone

DESCRIPTION:
  This function checks to see if there are more downlinks needed for
  the current Auto ID operations.  If there are more needed, this function
  posts a DeviceIDTx event.  Other wise it will post the AutoIDDone
  event.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_checkAutoIDDone(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_checkAutoIDDone = TRUE;
    tbm_disablePhysLayer(TRUE);
    tbm_AutoID_RespTimeout(&tbv_AutoID);
    return;
}

/********************************************************************

FUNCTION:
  tbm_closeDone

DESCRIPTION:

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_closeDone(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_closeDone = TRUE;
    /*
       Delete transmit timer.
     */
    tbm_cancelTimer(tbc_TxTimer);

    return;

}

/********************************************************************

FUNCTION:
  tbm_closeSession

DESCRIPTION:
  This function sends a telemetry B close session frame to the device.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_closeSession(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_closeSession = TRUE;
    /*
       Create the Telemetry B Close Session Frame.
     */
    tbv_dlFrames[0].length                    = 7;
    tbv_dlFrames[0].finalFrame                = (USHORT) TRUE;
    tbv_dlFrames[0].syncType                  = tbc_sc_normal;
    tbv_dlFrames[0].uplinkRate                = tbv_session.ConfigBPtr->defaultDataRate;
    tbv_dlFrames[0].frameType                 = tbt_dlUFrameClose;
    tbv_dlFrames[0].status                    = tbt_txInQueue;
    tbv_dlFrames[0].attemptCount              = 0;
    tbv_dlFrames[0].dlHeader                  = TBC_dlHeaderUFrameMode1;

    tbv_dlFrames[0].pgmrId[0]                 = (tbv_session.ProgrammerID >> 8) & 0xff;
    tbv_dlFrames[0].pgmrId[1]                 = tbv_session.ProgrammerID & 0xff;

    tbv_dlFrames[0].infoField[0]              = TBC_PROTOCOL_SOM_U; /* Start of Message Upper Byte */
    tbv_dlFrames[0].infoField[1]              = TBC_PROTOCOL_SOM_L; /* Start of Message Lower Byte */
    tbv_dlFrames[0].infoField[2]              = TBC_PROTOCOL_CLOSE_SESS; /* Command Code/Record Size */
    tbv_dlFrames[0].infoField[3]              = TBC_PROTOCOL_CC_CLOSE; /* Protocol Command */

    /*
       Create transmit timer.
       This timer will be removed automatically if it expires.  If the task
       is completed within time then this timer will be removed manually
       upon notification of task complete.
     */

    tbm_addTimer(tbm_noTx, tbc_TxTimer, TBC_500_MS_TIMER, 0);

    /*
       Queue the downlink frames.
     */
    tbm_enqueueEntry((tbt_queuePointer *) &tbv_dlFrameQ, &tbv_dlFrames[0]);
    return;

}

/********************************************************************

FUNCTION:
  tbm_concludeAutoID

DESCRIPTION:
  This function posts an event which signals the end of the AutoID
  operation.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_concludeAutoID(struct tbm_AutoID *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_concludeAutoID = TRUE;
    tbm_postEvent(&tbm_Chan_AutoIDDone);
}

/********************************************************************

FUNCTION:
  tbm_continueAutoID

DESCRIPTION:
  This function posts an event which causes another Telemetry B
  DEVICE ID request to be transmitted as a part of the ongoing
  Auto ID operation.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_continueAutoID(struct tbm_AutoID *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_continueAutoID = TRUE;
    tbm_postEvent(&tbm_Chan_DeviceIDTx);
}

/********************************************************************

FUNCTION: tbm_createDLframes

DESCRIPTION:

INPUTS:

OUTPUTS:

********************************************************************/
void tbm_createDLframes(void)
{
    UINT16 byteCount;
    UINT16 arrayCount;
    UINT16 dataCount;
    UINT16 copyLength;
    BYTE   *reqDataPtr;
    USHORT dlFrameSize;

    tbv_chanCoverage.tbm_chanCov_createDLframes = TRUE;

    /*
       Initialize variable used to build the individual Telemetry B
       downlink frames.
     */
    dataCount                                   = tbv_session.AppDataReqLen;
    reqDataPtr                                  = tbv_session.AppDataReqPtr;

    /*
       Determine the size of the downlink frames from the config B table
       based on the uplink data rate. Note: the 2490 Telemetry B hardware
       only supports these two data rates.
     */
    if (tbv_session.ConfigBPtr->defaultDataRate == tbc_dr_21)
        dlFrameSize = tbv_session.ConfigBPtr->maxDlIFieldSize2187;
    else if (tbv_session.ConfigBPtr->defaultDataRate == tbc_dr_87)
        dlFrameSize = tbv_session.ConfigBPtr->maxDlIFieldSize8750;
    else
        bsm_EHLock("tbm_telemBData: telemetry abuse, incorrect defaultDataRate.");

    /*
       Use the smallest of the two values tbv_session.ConfigBPtr->maxDlIFieldSizeXXXX
       or TBC_MAX_DL_IFIELD_SIZE.
     */
    if (dlFrameSize > TBC_MAX_DL_IFIELD_SIZE)
        dlFrameSize = TBC_MAX_DL_IFIELD_SIZE;

    /*
       Initialize array to indicate empty by marking each length as zero.
     */
    for (arrayCount = 0; arrayCount < TBC_DL_FRAME_Q_SIZE; arrayCount++)
    {
        tbv_dlFrames[arrayCount].length = 0;
    }

    /*
       Get the tag to be used for this Application Data Request.
     */
    {
        tbv_tag     = (++tbv_tag) & TBC_APP_TAG_FIELD_BYTE; /* tag is 0 thru 7. */
        /*
           Insert the Downlink TAG into the SOM word.
         */
        *reqDataPtr = ((*reqDataPtr & ~TBC_APP_TAG_FIELD_BYTE) | (tbv_tag));
    }
    /*
       Start the transmit timer before entering this while loop, because the Link
       layer can begin transmitting the downlink as soon as the first frame is placed in
       the queue.
       This timer will be removed automatically if it expires.  If the task
       is completed within time then this timer will be removed manually
       upon notification of task complete.
     */

    tbm_addTimer(tbm_noTx, tbc_TxTimer, 100,    //2 seconds
                 0);

    /*
       Break up the downlink request into one or more Telemetry B downlink frames.
     */
    arrayCount = 0;
    while (dataCount != 0)
    {

        tbv_dlFrames[arrayCount].syncType     = tbc_sc_normal;
        tbv_dlFrames[arrayCount].uplinkRate   =
            tbv_session.ConfigBPtr->defaultDataRate;
        tbv_dlFrames[arrayCount].finalFrame   = FALSE;

        tbv_dlFrames[arrayCount].frameType    = tbt_dlData;
        tbv_dlFrames[arrayCount].status       = tbt_txInQueue;
        tbv_dlFrames[arrayCount].attemptCount = 0;

        tbv_dlFrames[arrayCount].dlHeader     = 0x10;

        tbv_dlFrames[arrayCount].pgmrId[0]    = (tbv_session.ProgrammerID >> 8) & 0xff;
        tbv_dlFrames[arrayCount].pgmrId[1]    = tbv_session.ProgrammerID & 0xff;

        if (dlFrameSize < dataCount)
        {
            copyLength                      = dlFrameSize;
            tbv_dlFrames[arrayCount].length =
                dlFrameSize + TBC_PROTOCOL_OVERHEAD;
            dataCount                       = dataCount - dlFrameSize;
        }
        else
        {
            copyLength                          = dataCount;
            tbv_dlFrames[arrayCount].length     = dataCount + TBC_PROTOCOL_OVERHEAD;
            dataCount                           = 0;
            tbv_dlFrames[arrayCount].finalFrame = TRUE;
        }

        for (byteCount = 0; byteCount < copyLength; byteCount++)
        {
            tbv_dlFrames[arrayCount].infoField[byteCount] = *reqDataPtr++;
        }
        /*
           Queue the downlink frames.
         */
        tbm_enqueueEntry((tbt_queuePointer *) &tbv_dlFrameQ,
                         &tbv_dlFrames[arrayCount]);

        arrayCount++;
        if ((arrayCount > TBC_DL_FRAME_Q_SIZE) && (dataCount != 0))
            bsm_EHLock("tbm_createDLframes: DL Queue too small.");

    }                           /* end of while(dataCount) */

    return;
}

/********************************************************************

FUNCTION:
  tbm_deviceIDTx

DESCRIPTION:
  This function initialiates another Device ID downlink as part of the
  Auto ID operation.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_deviceIDTx(struct tbm_Chan *p_fsm)
{
    tbt_dlFrameType *framePtr;
    UINT16          count = 0;

    tbv_chanCoverage.tbm_chanCov_deviceIDTx = TRUE;

    /*
       Enable the transmit timer.
       This timer will be removed automatically if it expires.  If the task
       is completed within time then this timer will be removed manually
       upon notification of task complete.
     */
    tbm_addTimer(tbm_noTx, tbc_TxTimer, TBC_500_MS_TIMER, 0);

    /*
       Send the autoId frame to the Link layer.
     */
    framePtr = (tbt_dlFrameType *) (&(tbv_session.deviceIDFrame));

    /*
       Send the frame to the Link Layer.  If the Link layer cannot accept the frame due
       to it being busy and the maximum number of retries has expired, then declare that the
       request has failed due to a transmit timeout.
     */
    while (!(tbm_linkAutoID(framePtr)))
    {
        ++count;
        if (count >= TBC_MAX_CHAN_TX_RETRIES)
        {
            tbm_cancelTimer(tbc_TxTimer);
            tbm_postEvent(&tbm_Chan_TxTimeout);
            break;
        }
    }

    return;
}

/********************************************************************

FUNCTION:
  tbm_doAutoID

DESCRIPTION:
  This function starts the Auto ID operation.  It sets up the downlink
  frames and queues them to the Telemetry Link layer.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_doAutoID(struct tbm_Chan *p_fsm)
{
    tbt_dlFrameType *framePtr;
    UINT16          count = 0;

    tbv_chanCoverage.tbm_chanCov_doAutoID = TRUE;

    /*
       This function sets up the autoID operations.
     */

    /*
       Initialize the Auto ID FSM.
     */
    tbm_AutoID_initialize(&tbv_AutoID);

    /*
       Reset frame parameters.
     */
    tbv_session.deviceIDFrame.length       = 8;
    tbv_session.deviceIDFrame.dlHeader     = 0;
    tbv_session.deviceIDFrame.infoField[2] = 0xC3;  /* Command Code/Record Size */
    tbv_session.deviceIDFrame.infoField[4] = TBC_PROTOCOL_CC_DEV_ID;    /* Protocol ID/num target devices) */

    /*
       Enable the transmit timer.
       This timer will be removed automatically if it expires.  If the task
       is completed within time then this timer will be removed manually
       upon notification of task complete.
     */
    tbm_addTimer(tbm_noTx, tbc_TxTimer, TBC_500_MS_TIMER, 0);

    /*
       Send the autoId frame to the Link layer.
     */
    framePtr = (tbt_dlFrameType *) (&(tbv_session.deviceIDFrame));

    /*
       Send the frame to the Link Layer.  If the Link layer cannot accept the frame due
       to it being busy and the maximum number of retries has expired, then declare that the
       request has failed due to a transmit timeout.
     */
    while (!(tbm_linkAutoID(framePtr)))
    {
        ++count;
        if (count >= TBC_MAX_CHAN_TX_RETRIES)
        {
            tbm_cancelTimer(tbc_TxTimer);
            tbm_postEvent(&tbm_Chan_TxTimeout);
            break;
        }
    }

    return;
}

/********************************************************************

FUNCTION:
  tbm_doReturn

DESCRIPTION:
  This function was implemented to handle a Close session request when
  there is no active session, in which case we'll just return a successful
  status and do nothing else.  This function was written in a genaric
  format to be generally used if needed.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_doReturn(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_doReturn = TRUE;
    tbv_session.sessionStatus             = tbc_successful;
    tbm_clearMoreEventsFlag();
    return;
}

/********************************************************************

FUNCTION:
  tbm_EGMtimerExp

DESCRIPTION:
  This function posts an event which signals the conclusion of the
  tbm_telemBUplinks operation.

INPUTS:
 none

OUTPUTS:
  none

********************************************************************/
void tbm_EGMtimerExp(void)
{
    tbv_chanCoverage.tbm_chanCov_EGMtimerExp = TRUE;
    /*
       DataLink can stop doing sequence number checking on WFs
     */
    tbv_startWFsequenceChecking              = FALSE;

    tbm_postEvent(&tbm_Chan_CaptureDataDone);
    return;
}

/********************************************************************

FUNCTION: tbm_FreeFrame

DESCRIPTION:
  This function frees and uplink frame which is not needed for the
  current state and/or operations.

INPUTS:
  p_fsm

OUTPUTS:
  none

********************************************************************/
void tbm_FreeFrame(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_FreeFrame = TRUE;

    /*
       clear out a frame associated with an event that we don't care about.
     */
    (tbt_ulNonWaveFormType *) tbm_getQueueEntry((tbt_queuePointer) &
                                                tbv_ulFrameQ);
    tbm_dequeueEntry((tbt_queuePointer) & tbv_ulFrameQ);
}

/********************************************************************

FUNCTION: tbm_initLinkMode1

DESCRIPTION:
  This function initializes the Telemetry Link layer to Mode 1.  Mode 1
  means In Session with active telemetry.
  It starts the handshake timer at it's 250mS rate.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_initLinkMode1(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_initLinkMode1 = TRUE;
    tbv_linkMaintainSession                    = TRUE;

    if (!shortTimeoutTimerInitialized)
    {
        shortTimeoutTimerInitialized = TRUE;

        /*
           Initialize a timer to track short timeout from the device
           This timer will be reloaded automatically if it expires.  If the task
           is completed within time then this timer will be reloaded manually
           upon notification of task complete.
         */
        tbm_addTimer(tbm_shortTimeout,
                     tbc_STOTimer, TBC_240_MS_TIMER, TBC_240_MS_TIMER);

    }

    /*
       If this is not an app data request then it must be an EGM request,
       so start the EGM timer.
     */
    if (NULL == tbv_session.AppDataReqPtr)
    {
        tbm_addTimer(tbm_EGMtimerExp, tbc_EGMTimer, tbv_session.UplinkSampleTime * 50,  /* seconds * 50 ticks/second */
                     0);

        tbv_startWFsequenceChecking = TRUE;

    }
    else
    {
        /*
           Break the message into one or more Telemetry Frames and queue it to the
           Link layer for transmission.
         */
        tbm_createDLframes();
    }

    return;
}

/********************************************************************

FUNCTION: tbm_listenForDeviceIDResp

DESCRIPTION:
  This function transitions from the transmit to the receive portion of the
  DEVICE ID request.  It cancels the transmit timer and starts a receive
  timer to listen for the response.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_listenForDeviceIDResp(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_listenForDeviceIDResp = TRUE;

    /*
       Stop the tramsmit timer.
     */
    tbm_cancelTimer(tbc_TxTimer);
    /*
       Start the response timer
       This timer will be removed automatically if it expires.  If the task
       is completed within time then this timer will be removed manually
       upon notification of task complete.
     */
    tbm_addTimer(tbm_noResp, tbc_RxTimer, TBC_500_MS_TIMER, 0);

    return;
}

/********************************************************************

FUNCTION: tbm_listenForOpenResp

DESCRIPTION:
  This function transitions from the transmit to the receive portion of the
  OPEN request.  It cancels the transmit timer and starts a receive
  timer to listen for the response.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_listenForOpenResp(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_listenForOpenResp = TRUE;

    /*
       Stop the tramsmit timer.
     */
    tbm_cancelTimer(tbc_TxTimer);
    /*
       Start the response timer
       This timer will be removed automatically if it expires.  If the
       task is completed within time then this timer will be removed manually
       upon notification of task complete.
     */
    tbm_addTimer(tbm_noResp, tbc_RxTimer, TBC_500_MS_TIMER, 0);
    return;
}

/********************************************************************

FUNCTION:
  tbm_lossOfTelemetry

DESCRIPTION:
  This function handles the Channel operations which result from a loss of
  telemetry with the device.  An unsuccessful status will be returned to the
  Application.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_lossOfTelemetry(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_lossOfTelemetry = TRUE;
    tbv_session.sessionStatus                    = tbc_not_successful;
    return;
}

/********************************************************************

FUNCTION:  tbm_noResp

DESCRIPTION:
  This function handles the case where an expected device response is
  not received in the allotted wait time.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_noResp(void)
{
    tbv_chanCoverage.tbm_chanCov_noResp = TRUE;
    tbm_postEvent(&tbm_Chan_RespTimeout);
    return;
}

/********************************************************************

FUNCTION: tbm_noTx

DESCRIPTION:
  This function handles the case where an expected device response is
  not received in the allotted wait time.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_noTx(void)
{
    tbv_chanCoverage.tbm_chanCov_noTx = TRUE;
    tbm_disablePhysLayer(TRUE);
    tbm_postEvent(&tbm_Chan_TxTimeout);
    return;
}

/********************************************************************

FUNCTION:  tbm_openFail

DESCRIPTION:
  This function handles the processing of an Open Session Failure.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_openFail(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_openFail = TRUE;
    /*
       Stop the tramsmit timer.
     */
    tbm_cancelTimer(tbc_TxTimer);
    /*
       Stop the response timer
     */
    tbm_cancelTimer(tbc_RxTimer);

    tbv_session.sessionStatus = tbc_not_successful;
    tbm_clearMoreEventsFlag();

    tbm_disablePhysLayer(TRUE);
    return;
}

/********************************************************************

FUNCTION:   tbm_openSession

DESCRIPTION:
  This funtion initiates an Open Session with the device.  It queues
  the open downlink frame to the TL layer for transmit.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_openSession(struct tbm_Chan *p_fsm)
{
    BYTE   *fromPtr, *toPtr;
    UINT16 i;

    tbv_chanCoverage.tbm_chanCov_openSession = TRUE;
    /*
       Set up programmer id for link layer.
     */
    programmerID                             = tbv_session.ProgrammerID;

    /*
       Point to the Target ID from the application request.
     */
    fromPtr                                  = (BYTE *) tbv_session.TargetDeviceIDPtr;
    /*
       Copy the Target ID into the downlink Open Session Request.
     */
    toPtr                                    = (BYTE *) (&tbv_session.openSessFrame.infoField[5]);
    for (i = 0; i < TBC_DEVICE_ID_BYTE_SIZE; i++)
    {
        *toPtr++ = *fromPtr++;
    }

    /*
       Set up the listen rate for the Link.
     */
    tbv_session.openSessFrame.uplinkRate =
        tbv_session.ConfigBPtr->defaultDataRate;
    /*
       Protocol ID (uplink rate)
     */
    /*
       Set up the uplink rate in the device message.
     */
    if (tbv_session.openSessFrame.uplinkRate == tbc_dr_21)
        tbv_session.openSessFrame.infoField[4] = TBC_OPEN_DATA_RATE_021;
    else                        // Uplink rate is tbc_dr_87.
        tbv_session.openSessFrame.infoField[4] = TBC_OPEN_DATA_RATE_087;

    tbv_session.openSessFrame.pgmrId[0]     = (tbv_session.ProgrammerID >> 8) & 0xff;
    tbv_session.openSessFrame.pgmrId[1]     = tbv_session.ProgrammerID & 0xff;

    tbv_session.openSessFrame.infoField[11] = (tbv_session.ProgrammerID >> 8) & 0xff;
    tbv_session.openSessFrame.infoField[12] = tbv_session.ProgrammerID & 0xff;

    /*
       Create a timer for the Open.
       This timer will be removed automatically if it expires.  If the
       task is completed within time then this timer will be removed manually
       upon notification of task complete.
     */
    tbm_addTimer(tbm_noTx, tbc_TxTimer, TBC_500_MS_TIMER, 0);

    /*
       send the frame to the Link
     */
    /*
       Send the frame to the Link Layer.  If the Link layer cannot accept the frame due
       to it being busy and the maximum number of retries has expired, then declare that the
       request has failed due to a transmit timeout.
     */
    i = 0;
    while (!(tbm_OpenDLReq((tbt_dlFrameType *) &tbv_session.openSessFrame)))
    {
        ++i;
        if (i >= TBC_MAX_CHAN_TX_RETRIES)
        {
            tbm_cancelTimer(tbc_TxTimer);
            tbm_postEvent(&tbm_Chan_TxTimeout);
            break;
        }
    }

    ++openSessionCnt;

    return;
}

/********************************************************************

FUNCTION:
  tbm_processDeviceIDResp

DESCRIPTION:
  This function processes the uplink response to the Device ID downlink.
  Get the frame from the queue.
  Verify that it is the Response.
  Copy the received Device ID into the buffer to be handed back to the
  caller.
  Copy the received Device ID into the Device ID downlink frame in
  preparaion for the next downlink.

  If there is no frame in the queue, then it is an error.
  If there is a frame, but it's not the one we're waiting for, then
  it is not an error, just continue waiting.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_processDeviceIDResp(struct tbm_Chan *p_fsm)
{
    void                  *retPtr   = NULL;
    tbt_ulNonWaveFormType *framePtr = NULL;
    BYTE                  *toPtr2, *tmpDataPtr, *tmpRespPtr;
    UINT16                i, n, numDevices;
    bool                  duplicate, temp_dup;

    tbv_chanCoverage.tbm_chanCov_processDeviceIDResp = TRUE;
    /*
       Get the next uplink frame from the uplink queue. Then dequeue that
       entry.
     */
    retPtr                                           = tbm_getQueueEntry((tbt_queuePointer) & tbv_ulFrameQ);
    tbm_dequeueEntry((tbt_queuePointer) & tbv_ulFrameQ);

    if (NULL != retPtr)
    {
        framePtr = (tbt_ulNonWaveFormType *) retPtr;
        /*
           Check the uplink command code to see if its the device ID response.
         */
        if (TBC_PROTOCOL_DEV_ID_RR == framePtr->cmdCode)
        {
            /*
               Before adding a new device ID response, determine if it
               is a duplicate of one already in the summary response.  If
               it is then don't add it; discard it instead.
             */
            tmpDataPtr = (BYTE *) &(tbv_session.DeviceIDRespPtr->response[0]);
            numDevices = (USHORT) tbv_session.DeviceIDRespPtr->numberFound;
            duplicate  = FALSE;

            /*
               Compare the device id of the latest response against all
               he past responses.
             */
            for (i = 0; i < numDevices; i++)
            {
                tmpRespPtr = (BYTE *) &framePtr->infoField[0];
                temp_dup   = TRUE;
                for (n = 0; n < TBC_DEVICE_ID_BYTE_SIZE; n++)
                {
                    if (*tmpDataPtr != *tmpRespPtr)
                    {
                        temp_dup = FALSE;
                    }
                    tmpDataPtr++;
                    tmpRespPtr++;
                }
                duplicate = duplicate || temp_dup;
            }

            if (!duplicate)
            {
                /*
                   Copy the Uplinked Device Information to the End  of the response uplink frame.
                 */
                /*
                   Verify that there are 15 or fewer Device ID's already in the response.
                 */
                if (TBC_MAX_NUMBER_OF_DEVICES >
                    tbv_session.DeviceIDRespPtr->numberFound)
                {
                    /*
                       Point to the uplinked device ID.
                     */
                    tmpRespPtr = (BYTE *) &framePtr->infoField[0];
                    /*
                       Point to location to store device ID.
                     */
                    tmpDataPtr = (BYTE *)
                                 &(tbv_session.DeviceIDRespPtr->
                                   response[(tbv_session.DeviceIDRespPtr->
                                             numberFound)]);
                    /*
                       Copy the new response if there is room.
                     */
                    for (i = 0; i < TBC_DEVICE_ID_BYTE_SIZE; i++)
                    {
                        *tmpDataPtr++ = *tmpRespPtr++;
                    }
                    /*
                       Update the number of device ID's received.
                     */
                    tbv_session.DeviceIDRespPtr->numberFound += 1;
                }

                /*
                   Verify that there is room remaining the Device ID downlink
                   frame before adding this one. There is only 4 allowed due to max downlink size of 30 records.
                 */
                if (((tbv_session.deviceIDFrame.
                      infoField[TBC_PROTOCOL_DL_ID_BYTE]) & 0x07) <
                    TBC_MAX_TARGETS_PER_DEVICE_ID)
                {
                    /*
                       Point to the uplinked device ID.
                     */
                    tmpRespPtr = (BYTE *) &framePtr->infoField[0];
                    /*
                       Include the received device ID in the next downlink device ID request.
                     */
                    toPtr2     = (BYTE *)
                                 (&tbv_session.deviceIDFrame.dlHeader +
                                  tbv_session.deviceIDFrame.length);
                    for (i = 0; i < TBC_DEVICE_ID_BYTE_SIZE; i++)
                    {
                        *toPtr2++ = *tmpRespPtr++;
                    }
                    /*
                       Update the length of the downlink Frame.
                     */
                    tbv_session.deviceIDFrame.length += TBC_DEVICE_ID_BYTE_SIZE;
                    /*
                       Update the downlink command code to indicate that there is another Device ID
                       in the downlink request.
                     */
                    /*
                       Command Code/Record Size
                     */
                    (tbv_session.deviceIDFrame.
                     infoField[TBC_PROTOCOL_DL_CC_BYTE]) +=
                        TBC_DEVICE_ID_BYTE_SIZE;
                    /*
                       Protocol ID/target devices
                     */
                    (tbv_session.deviceIDFrame.
                     infoField[TBC_PROTOCOL_DL_ID_BYTE])++;
                }

                /*
                   Update Auto ID State Machine.
                 */
                tbm_AutoID_UniqueRespRx(&tbv_AutoID);
            }                   /* end of !duplicate */
            else                /* Frame is a duplicate response of one already received. */
            {
                /*
                   discard the frame
                 */
                asm ("	nop");
            }
        }                       /* end of TBC_PROTOCOL_DEV_ID check */
        else                    /* Frame is not a response to the device ID request. */
        {
            /*
               do nothing
             */
            asm ("	nop");
        }
    }                           /* end of retPtr != NULL check */
    else                        /* Nothing in queue.  This is an error. */
    {
        bsm_EHLock("tbm_processDeviceIDResp: queue empty.");
    }
    return;
}

/********************************************************************

FUNCTION:
  tbm_processMissedWF

DESCRIPTION:
  This function processes the report of a missing waveform during EGM
  capture.  This is not a telemetry failure per se, it is simply that the
  EGM capture must not miss any waveforms during it's duration. This function
  should not shut down the Telemetry Session, but it should provide to
  return back to the Application the status to indicate the EGM capture was
  not successful.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_processMissedWF(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_processMissedWF = TRUE;

    /*
       DataLink can stop doing sequence number checking on WFs
     */
    tbv_startWFsequenceChecking                  = FALSE;

    /*
       Terminate event processor.
     */
    tbv_session.sessionStatus                    = tbc_not_successful;

}

/********************************************************************

FUNCTION:
  tbm_processOpenResp

DESCRIPTION:
  This function process the uplink response to the OPEN SESSION downlink.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_processOpenResp(struct tbm_Chan *p_fsm)
{
    tbt_ulNonWaveFormType *framePtr;

    tbv_chanCoverage.tbm_chanCov_processOpenResp = TRUE;

    framePtr                                     =
        (tbt_ulNonWaveFormType *) tbm_getQueueEntry((tbt_queuePointer) &
                                                    tbv_ulFrameQ);
    tbm_dequeueEntry((tbt_queuePointer) & tbv_ulFrameQ);

    if (TBC_PROTOCOL_REJECT == framePtr->cmdCode)
    {
        /*
           Disable the response timer.
         */
        tbm_cancelTimer(tbc_RxTimer);
        tbm_postEvent(&tbm_Chan_OpenFail);
    }
    else if (TBC_PROTOCOL_OPEN_SESS_RR == framePtr->cmdCode)
    {
        /*
           Disable the response timer.
         */
        tbm_cancelTimer(tbc_RxTimer);
        tbm_postEvent(&tbm_Chan_OpenDone);
    }
    else
    {
        /*
           ignore frame
         */
    }
    return;
}

/********************************************************************

FUNCTION:
  tbm_processULnonWFFrame

DESCRIPTION:
  This function processes all uplink non-Waveform Frames received while
  in session with a device. If the current operation
  is tbm_telemBData, then uplink Waveform Frames are ignored.  This
  function may post event CaptureDataDone when either the allotted
  time has expired or the allotted buffer has been filled.

  This function may receive the following types of frames:
  Un-numbered frames, which could include protocol responses and
    supplemental markers.
  Data frames - non-waveform, which are the responses to the Application Data
    requests.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_processULnonWFFrame(struct tbm_Chan *p_fsm)
{
    tbt_ulNonWaveFormType *framePtr;
    UINT16                copyLength, i;
    BYTE                  cmdCode;
    BYTE                  *toPtr, *fromPtr;

    tbv_chanCoverage.tbm_chanCov_processULnonWFFrame = TRUE;

    framePtr                                         =
        (tbt_ulNonWaveFormType *) tbm_getQueueEntry((tbt_queuePointer) &
                                                    tbv_ulFrameQ);
    tbm_dequeueEntry((tbt_queuePointer) & tbv_ulFrameQ);

    cmdCode = framePtr->cmdCode;
    /*
       Determine whether or not this frame should be added to the response buffer.
     */
    /*
       If this is an EGM capture operation.
     */
    if (NULL == tbv_session.AppDataReqPtr)
    /*
       Structured copy of Frame to Buffer
     */
    {
        if (TBC_APP_UNREQUESTED_UPLINK == (cmdCode & (~TBC_APP_TAG_FIELD_BYTE)))
        {
            /*
               Capture nonWaveform frame in the structured response buffer.
             */
            tbv_respCurrentLength = *tbv_session.bufferUsedLengthPtr;
            toPtr                 = tbv_session.RespPtr + tbv_respCurrentLength;
            copyLength            = framePtr->length;

            if ((tbv_respCurrentLength + copyLength + 0x0003) <=
                tbv_session.MaxBufferSize)
            {
                *toPtr++ = (BYTE) ((copyLength + 0x0003) & (0xff00)) >> 8;
                *toPtr++ = (BYTE) ((copyLength + 0x0003) & (0x00ff));
                *toPtr++ = 0x00;
                /*
                   Use Datalink header as the frame identifier in the response buffer.
                 */
                fromPtr  = &framePtr->dlHeader;
                for (i = 0; i < copyLength; i++)
                {
                    *toPtr++ = *fromPtr++;
                }
                /*
                   Update overall response length, include the frame just added and its header.
                 */
                tbv_respCurrentLength           += (copyLength + 0x0003);
                *tbv_session.bufferUsedLengthPtr = tbv_respCurrentLength;
            }
            else                /* Not enough room in the response buffer.  */
            {
                tbm_postEvent(&tbm_Chan_CaptureDataDone);
            }
        }
    }

    /*
       If this is a Data capture operation.
     */
    else if (((TBC_APP_REQUESTED_RR == (cmdCode & (~TBC_APP_TAG_FIELD_BYTE))) ||
              (TBC_APP_REQUESTED_REJECT ==
               (cmdCode & (~TBC_APP_TAG_FIELD_BYTE)))
              || (TBC_APP_REQUESTED_UPLINK ==
                  (cmdCode & (~TBC_APP_TAG_FIELD_BYTE))))
             && ((cmdCode & TBC_APP_TAG_FIELD_BYTE) == tbv_tag))
    {
        /*
           Disable the response timer.
         */
        tbm_cancelTimer(tbc_RxTimer);
        /*
           Get the current length of the filled buffer.
         */
        tbv_respCurrentLength = *tbv_session.bufferUsedLengthPtr;

        /*
           Check to see if the command code has already been set, meaning
           that the first frame has already been received.
         */
        toPtr                 = tbv_session.RespPtr;
        if (*(toPtr + 1) == 0x00)
        {
            *toPtr++ = 0x00;
            tbv_respCurrentLength++;

            *toPtr++ = cmdCode;
            tbv_respCurrentLength++;

        }
        else
        {
            toPtr = tbv_session.RespPtr + tbv_respCurrentLength;
        }

        copyLength = framePtr->length - TBC_APP_UL_OVERHEAD;    /* Don't copy DataLink Header or CmdCode */

        /*
           Capture the uplink frame and place it in the response buffer.
         */
        if ((tbv_respCurrentLength + copyLength) <= tbv_session.MaxBufferSize)
        {
            fromPtr = (BYTE *) &framePtr->infoField;
            for (i = 0; i < copyLength; i++)
            {
                *toPtr++ = *fromPtr++;
            }
            /*
               Update filled response buffer length with the frame just added.
             */
            tbv_respCurrentLength           += copyLength;
            /*
               Update overall response length, include the frame just added and its header.
             */
            *tbv_session.bufferUsedLengthPtr = tbv_respCurrentLength;

            /*
               Check for final frame.
             */
            if (framePtr->finalFrame)
            {
                tbm_postEvent(&tbm_Chan_CaptureDataDone);
            }
            else
            {
                /*
                   If this is not the final frame then restart the response timer.
                 */
                tbm_addTimer(tbm_noResp, tbc_RxTimer, TBC_500_MS_TIMER, 0);

            }
        }
        else                    /* Not enough room in the response buffer.  */
        {
            /*
               This should never happen, the application request should ensure that it provides
               a buffer large enough to handle the uplink response.
             */
            tbv_session.sessionStatus = tbc_telemetry_abuse;
            tbm_postEvent(&tbm_Chan_CaptureDataFail);
        }
    }

    /*
       This is a data capture operation, but the values in the uplink frame do not match the expected.
     */
    else
    {
        /*
           Ignore this uplink frame.
         */
    }

    return;
}

/********************************************************************

FUNCTION:
  tbm_processULWaveform

DESCRIPTION:
  This function processes all uplink Waveform Frames received while
  in session with a device. If the current operation
  is tbm_telemBData, then uplink Waveform Frames are ignored.  This
  function may post event CaptureDataDone when either the allotted
  time has expired or the allotted buffer has been filled.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_processULWaveform(struct tbm_Chan *p_fsm)
{
    tbt_ulWaveFormType *framePtr;
    BYTE               *toPtr, *fromPtr;
    UINT16             i, copyLength;

    tbv_chanCoverage.tbm_chanCov_processULWaveform = TRUE;

    framePtr                                       =
        (tbt_ulWaveFormType *) tbm_getQueueEntry((tbt_queuePointer) &
                                                 tbv_ulFrameQ);
    tbm_dequeueEntry((tbt_queuePointer) & tbv_ulFrameQ);
#ifdef DEBUG_STATE
    ++stateIndex;
    stateIndex       &= STATE_MASK;
    state[stateIndex] = tbt_ChannelWFProcessed;
#endif

    if (NULL == tbv_session.AppDataReqPtr)
    {
        /*
           Capture all uplink frames and place them in the response buffer.
         */
        tbv_respCurrentLength = *tbv_session.bufferUsedLengthPtr;
        toPtr                 = tbv_session.RespPtr + tbv_respCurrentLength;
        /*
           Check for a valid frame.
         */
        if ((framePtr->length <= 2) || (0x00 == framePtr->dlHeader))
            return;

        copyLength = framePtr->length - 0x0002; /* Deduct for programmer ID. */

        if ((tbv_respCurrentLength + copyLength + 0x0003) <=
            tbv_session.MaxBufferSize)
        {
            *toPtr++ = (BYTE) ((copyLength + 0x0003) & (0xff00)) >> 8;
            *toPtr++ = (BYTE) ((copyLength + 0x0003) & (0x00ff));
            /*
               Use Datalink header as the frame identifier in the response buffer.
             */
            *toPtr++ = 0x00;
            *toPtr++ = framePtr->dlHeader;
            /*
               Skip the programmer ID in the framePtr Uplink waveform.
             */
            fromPtr  = (BYTE *) &framePtr->infoField;
            /*
               i starts at 1 to reduce for dl Header already copied in.
             */
            for (i = 1; i < copyLength; i++)
            {
                *toPtr++ = *fromPtr++;
            }

            /*
               Update total response length.
             */
            tbv_respCurrentLength           += (copyLength + 0x0003);
            /*
               Update overall response length, include the frame just added and its header.
             */
            *tbv_session.bufferUsedLengthPtr = tbv_respCurrentLength;
        }
        else                    /* Not enough room in the response buffer.  */
        {
            tbm_postEvent(&tbm_Chan_CaptureDataDone);
        }
    }
    else                        /* Processing the Downlink Application Data Feature. */
    {
        /*
           Ignore uplink waveforms while capturing AppData Responses from
           the device.
         */
    }

    return;
}

/********************************************************************

FUNCTION:
  tbm_processWFOpenResp

DESCRIPTION:
  This function process a Uplink Waveform frame as a response to the
  Open Session downlink.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_processWFOpenResp(struct tbm_Chan *p_fsm)
{
    tbt_ulWaveFormType *framePtr;

    tbv_chanCoverage.tbm_chanCov_processWFOpenResp = TRUE;

    framePtr                                       =
        (tbt_ulWaveFormType *) tbm_getQueueEntry((tbt_queuePointer) &
                                                 tbv_ulFrameQ);
    tbm_dequeueEntry((tbt_queuePointer) & tbv_ulFrameQ);

    if (framePtr->pgmrId[0] == ((tbv_session.ProgrammerID >> 8) & 0xff) &&
        framePtr->pgmrId[1] == (tbv_session.ProgrammerID & 0xff))
    {
        /*
           Disable the response timer.
         */
        tbm_cancelTimer(tbc_RxTimer);
        tbm_postEvent(&tbm_Chan_OpenDone);
    }
    return;
}

/********************************************************************

FUNCTION:  tbm_startAppDataTimer

DESCRIPTION:
  This function starts a timer to wait for the device response to the
  Application Data Request.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_startAppDataTimer(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_startAppDataTimer = TRUE;
    /*
       Enable a timer for the expected uplink response.
       This timer will be removed automatically if it expires.  If the
       task is completed within time then this timer will be removed manually
       upon notification of task complete.
     */
    tbm_addTimer(tbm_noResp,
                 tbc_RxTimer,
                 (tbv_session.ConfigBPtr->memUplinkRespTimeout / 20), 0);

    return;

}

/********************************************************************

FUNCTION:
  tbm_stopLinkMode1

DESCRIPTION:
  This function shuts down MODE 1 operations in the Telemetry Module.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_stopLinkMode1(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_stopLinkMode1 = TRUE;
    tbv_linkMaintainSession                    = FALSE;
    shortTimeoutTimerInitialized               = FALSE;

    /*
       Cancel the short time out timer
     */
    tbm_cancelTimer(tbc_STOTimer);

    tbm_clearMoreEventsFlag();

    tbm_disablePhysLayer(TRUE);
}

/********************************************************************

FUNCTION:  tbm_stopSession

DESCRIPTION:
  This function clears the moreEventsFlag.
INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_stopSession(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_stopSession = TRUE;
    tbm_clearMoreEventsFlag();
}

/********************************************************************

FUNCTION:  tbm_tlmAbuse

DESCRIPTION:
  This function is used to handle any attempts by the Application to
  perform any illegal Telemetry operations.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_tlmAbuse(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_tlmAbuse = TRUE;
    tbm_cancelTimer(tbc_RxTimer);
    tbm_cancelTimer(tbc_TxTimer);

    tbv_session.sessionStatus = tbc_telemetry_abuse;
    tbm_clearMoreEventsFlag();
    tbm_disablePhysLayer(TRUE);
    return;
}

/********************************************************************

FUNCTION:  tbm_txTimeoutMode1

DESCRIPTION:
  A transmit failure has occured while in operating Mode 1.  This implies
  that the attempted downlink was to be sent synchronously and with
  normal sync characters.  This type of failure may occur it the device moves
  out of range from the rf head.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_txTimeoutMode1(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_txTimeoutMode1 = TRUE;
    tbv_session.sessionStatus                   = tbc_not_successful;
    return;
}

/********************************************************************

FUNCTION:  tbm_txTimeoutMode2

DESCRIPTION:
  A transmit failure has occured while in operating Mode 2.  This implies
  that the attempted downlink was to be sent asynchronously and with
  extended sync characters.  This should always transmit.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_txTimeoutMode2(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_txTimeoutMode2 = TRUE;
    tbm_disablePhysLayer(TRUE);
    tbm_clearMoreEventsFlag();
    tbv_session.sessionStatus                   = tbc_fail;

    return;
}

/********************************************************************

FUNCTION:  tbm_unexpTelemEvent

DESCRIPTION:
  This is debug code to count the number of times an unexpected
  state machine action takes place.

INPUTS:
  p_fsm : not used, included to match the SMC generated code.

OUTPUTS:
  none

********************************************************************/
void tbm_unexpTelemEvent(struct tbm_Chan *p_fsm)
{
    tbv_chanCoverage.tbm_chanCov_unexpTelemEvent = TRUE;
    tbv_unexpEventCounter++;
}
