#!/usr/bin/perl
#	This script traverses through a host build, and searches for all
#	data that is being used by the code. It takes the varibles and builds
#	xref.cat

BEGIN {
	push (@INC, "local", "../local", "w:/utility/tools", "c:/apps/bin");
#	push (@INC, "local", "../local");
	require vocal; import vocal;
	require vocalmdm; import vocalmdm;
}

sub usage
{
	my ($retval) = @_;
	print "Usage: makesyml <sourcedir> > outfile\n";
	exit ($retval);
}


## ######################################################################### ##
#       Main routine
## ######################################################################### ##

undef $/;
&set_print_debug_level(0);
	%found_var = ();


$option__strip_files = 1;			# strip file by default
$option__linkgrp_file = "arch/mst_link.src";		# use (source)/arch/mst_link.src by default

while ($ARGV[0] =~ m/^([\+\-])(\S+)/) {
	$arg = shift;
	$indicator = $1;
	$option = lc ($2);
	if ($option eq "h") {
		&usage (0);
	}
}
&usage (1) unless (@ARGV == 1);
$source = shift;


## ######################################################################### ##
#       Determine OS and runtime environment
## ######################################################################### ##

# dredge out the OS type for later use
# win9x based OS returns "" , nt based returns "Windows_NT", linux returns linux-gnu
# if this isnt working on your linux system you might have to export OSTYPE
$os_name = $ENV{OS};
$os_type = $ENV{OSTYPE};

# check for linux first, set os_name if needed
if($os_name eq "linux-gnu") {
	$os_name = "linux";
}
if($os_type eq "linux-gnu") {
	$os_name = "linux";
}
if($os_type eq "linux") {
	$os_name = "linux";
}

# check for old windows 98
if($os_name eq "") {
	$os_name = $os_type;
}
if($os_name eq "") {
	$os_name = "Windows_98";
}

# now make the decision between win98, nt/xp, and linux
if($os_name eq "Windows_98"){
	# windows 98
	$cpp = "local/CPP0";
	$redir = "";
}
elsif($os_name eq "Windows_NT") {
	$cpp = "CPP0";
	$redir = "2>nul";
}
else {
	# linux/unix variants
	$cpp = "cpp";
	$redir = "2>/dev/null";
}

$output = `$cpp --help`;
if ($output eq "") {
	print "Error in finddata.prl - unable to run $cpp.\n";
	print "\n";
	print "\n";
	print "If running under linux, make sure you 'export OSTYPE=linux'\n";
	print "\n";
	print "\n";
	exit(1);
}


# win9x based OS returns "", others return a string
if($os_name eq "Windows_98") {
	open(STDERR, ">nul");
}
# print "\nGot os type $os_name.\n";


## ######################################################################### ##
#	read in options.h and load options into storage for strip util etc.
## ######################################################################### ##


&load_options_file_ii ("include/options.h");
&load_options_file ("include/reconfig.h");
&load_options_file ("include/test.h");

&set_options (
			  "notdef",							"u",
			  "PSEUDO_CODE",					"u",
			  "PSEDUO_CODE",					"u",
			  "C_CODE",							"u",
			  "NOTDEF",							"u",
			  "NOT_USED",						"u",
			  "OLD_CODE",						"u",
			  "DO_REMOVE",						"u",
			  "DO_STRIP_DEFINED_FOR_RELEASE",	"d",
			 );



$source_linkgrp = "${option__linkgrp_file}";
open (LINKGRP, $source_linkgrp) || die ("Cannot open link file: ${$source_linkgrp}\n");
$linkgrp__contents = <LINKGRP>;
close (LINKGRP);
&strip ($linkgrp__contents);


undef %obj_dirs;
while ($linkgrp__contents =~ m!^\s*link/(\w+)/([\w\@\!]+)!gm) {
	$path = "${1}/${2}";
	$dir = $1;
	$base_filename = $2;

	$obj_files {$path} = $dir;
	$obj_dirs {$dir} .= "${base_filename},";
}
@obj_file_list = sort keys %obj_files;

%source_dirs = %obj_dirs;


## ######################################################################### ##
#	Actually build the data lists
## ######################################################################### ##

print "\nBuilding \\data\\xref.cat\n";

# create list of c files
foreach $dir (sort keys %source_dirs) {

	undef %mk_c_files;
	foreach $file (split (/,/, $source_dirs {$dir})) {
		next if $file eq "";
		$mk_c_files {$file} = 1;
#		print "\n[$file]";
	}

	$tempcnt = 0;
	foreach $temp (sort keys %mk_c_files) {
		$tempcnt++;
		next if $temp eq "";
#		print "\n$temp";

		$output = `$cpp -DBUILDING_DATA -I. -I.. -P $dir/$temp.c $redir`;

		if ($output eq "") {
			print "\nWarning, file $dir/$temp.c appears to be empty.\n";
		}
		print ".";

		foreach $line (split (/\n/, $output)) {
			while ($line =~ m/DATASTRUCT([\._a-zA-Z0-9]*)\._([_a-zA-Z0-9]+)/) {
				$local_var_name = $2;
				$local_line = $line;
				$line = $';

				# these checks are to stop weak initialization from being the source
				# of data instantiation - previously only defining BUILDING_DATA around
				# the sections would prevent this.  This allows greater flexibility and
				# granularity -dave

				if ($local_line =~ m"WEAK\s*\(\s*([^,]+?)\s*,\s*(.+)\)") {
#					print stderr  "\n\t\t\t\t$dir/$temp.c" ." $local_var_name ";
					next;
				}
				if ($local_line =~ m"WEAK_BUFFER_CLEAR\s*\(\s*([^,]+?)\s*\)") {
#					print stderr  "\n\t\t\t\t$dir/$temp.c" ." $local_var_name ";
					next;
				}
				if ($local_line =~ m"WEAK_STRUCTURE_CLEAR\s*\(\s*([^,]+?)\s*\)") {
#					print stderr  "\n\t\t\t\t$dir/$temp.c" ." $local_var_name ";
					next;
				}
				if ($local_line =~ m/(?:[^\/]+|^)SNMP_ITEM.*?}\s*,\s*/ ) {
#					print stderr  "\n\t\t\t\t$dir/$temp.c" ." $local_var_name ";
					next;
				}

				$found_var{$local_var_name}{$temp} = "$dir/$temp.c";
#				print stderr  $found_var{$2}{$temp} ." $local_var_name\n";
			}

		}
	}
}

if($os_name eq "Windows_98"){
	close(STDERR);
	open(STDERR, ">-");
}

open (XREFLIST, ">data/xref.cat") || return print "\nfinddata.prl: FAILED opening XREF catalog file\n";
foreach $var (keys %found_var) {
	print XREFLIST "\n$var: ";
#	print stderr "\n$var";
	foreach $file (keys %{$found_var{$var}}) {
		print XREFLIST "$found_var{$var}{$file} ";
	}
}
close (XREFLIST);

print "\n\\data\\xref.cat built";
if($os_name eq "Windows_98"){
	print ", close window to continue";
}
print "\n";
